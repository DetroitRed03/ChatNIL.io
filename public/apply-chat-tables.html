<!DOCTYPE html>
<html>
<head>
  <title>Apply Chat Tables</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
  <h1>Applying Chat Tables Migration...</h1>
  <pre id="output"></pre>

  <script type="module">
    const output = document.getElementById('output');
    function log(msg) {
      output.textContent += msg + '\n';
      console.log(msg);
    }

    const SUPABASE_URL = 'https://lqskiijspudfocddhkqs.supabase.co';
    const SERVICE_ROLE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imxxc2tpaWpzcHVkZm9jZGRoa3FzIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2MTU5MzM1NCwiZXhwIjoyMDc3MTY5MzU0fQ.LpapT51choXCwTfpbE81AIc4JC9QOO0FpOtqUxZ405I';

    const supabase = window.supabase.createClient(SUPABASE_URL, SERVICE_ROLE_KEY);

    async function runSQL(sql) {
      const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/exec_sql`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'apikey': SERVICE_ROLE_KEY,
          'Authorization': `Bearer ${SERVICE_ROLE_KEY}`
        },
        body: JSON.stringify({ sql_query: sql })
      });

      if (!response.ok) {
        const text = await response.text();
        throw new Error(`HTTP ${response.status}: ${text}`);
      }

      return response.json();
    }

    async function applyMigrations() {
      log('ðŸ”§ Creating Chat Tables...\n');

      // First, create the update_updated_at_column function if it doesn't exist
      log('ðŸ“ Creating helper function...');
      try {
        await runSQL(`
          CREATE OR REPLACE FUNCTION update_updated_at_column()
          RETURNS TRIGGER AS $$
          BEGIN
              NEW.updated_at = now();
              RETURN NEW;
          END;
          $$ language 'plpgsql';
        `);
        log('âœ… Helper function created\n');
      } catch (err) {
        log('âš ï¸  Helper function: ' + err.message + '\n');
      }

      // Create chat_sessions table
      log('ðŸ“ Creating chat_sessions table...');
      try {
        await runSQL(`
          CREATE TABLE IF NOT EXISTS chat_sessions (
            id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
            user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
            title text NOT NULL DEFAULT 'New Chat',
            role_context text DEFAULT 'athlete',
            is_pinned boolean DEFAULT false,
            is_archived boolean DEFAULT false,
            draft text DEFAULT '',
            created_at timestamp with time zone DEFAULT now(),
            updated_at timestamp with time zone DEFAULT now()
          );

          ALTER TABLE chat_sessions ENABLE ROW LEVEL SECURITY;

          DROP POLICY IF EXISTS "Users can view own chat sessions" ON chat_sessions;
          CREATE POLICY "Users can view own chat sessions" ON chat_sessions
            FOR SELECT USING (auth.uid() = user_id);

          DROP POLICY IF EXISTS "Users can create own chat sessions" ON chat_sessions;
          CREATE POLICY "Users can create own chat sessions" ON chat_sessions
            FOR INSERT WITH CHECK (auth.uid() = user_id);

          DROP POLICY IF EXISTS "Users can update own chat sessions" ON chat_sessions;
          CREATE POLICY "Users can update own chat sessions" ON chat_sessions
            FOR UPDATE USING (auth.uid() = user_id);

          DROP POLICY IF EXISTS "Users can delete own chat sessions" ON chat_sessions;
          CREATE POLICY "Users can delete own chat sessions" ON chat_sessions
            FOR DELETE USING (auth.uid() = user_id);

          DROP POLICY IF EXISTS "Service role can manage all chat sessions" ON chat_sessions;
          CREATE POLICY "Service role can manage all chat sessions" ON chat_sessions
            FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');

          CREATE INDEX IF NOT EXISTS idx_chat_sessions_user_id ON chat_sessions(user_id);
          CREATE INDEX IF NOT EXISTS idx_chat_sessions_updated_at ON chat_sessions(updated_at DESC);

          DROP TRIGGER IF EXISTS update_chat_sessions_updated_at ON chat_sessions;
          CREATE TRIGGER update_chat_sessions_updated_at
            BEFORE UPDATE ON chat_sessions
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
        `);
        log('âœ… chat_sessions table created\n');
      } catch (err) {
        log('âŒ chat_sessions error: ' + err.message + '\n');
      }

      // Create chat_messages table
      log('ðŸ“ Creating chat_messages table...');
      try {
        await runSQL(`
          CREATE TABLE IF NOT EXISTS chat_messages (
            id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
            session_id uuid NOT NULL REFERENCES chat_sessions(id) ON DELETE CASCADE,
            user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
            role text NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
            content text NOT NULL,
            metadata jsonb DEFAULT '{}',
            created_at timestamp with time zone DEFAULT now()
          );

          ALTER TABLE chat_messages ENABLE ROW LEVEL SECURITY;

          DROP POLICY IF EXISTS "Users can view own messages" ON chat_messages;
          CREATE POLICY "Users can view own messages" ON chat_messages
            FOR SELECT USING (auth.uid() = user_id);

          DROP POLICY IF EXISTS "Users can create own messages" ON chat_messages;
          CREATE POLICY "Users can create own messages" ON chat_messages
            FOR INSERT WITH CHECK (auth.uid() = user_id);

          DROP POLICY IF EXISTS "Service role can manage all messages" ON chat_messages;
          CREATE POLICY "Service role can manage all messages" ON chat_messages
            FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');

          CREATE INDEX IF NOT EXISTS idx_chat_messages_session_id ON chat_messages(session_id);
          CREATE INDEX IF NOT EXISTS idx_chat_messages_created_at ON chat_messages(created_at DESC);
        `);
        log('âœ… chat_messages table created\n');
      } catch (err) {
        log('âŒ chat_messages error: ' + err.message + '\n');
      }

      // Create chat_attachments table
      log('ðŸ“ Creating chat_attachments table...');
      try {
        await runSQL(`
          CREATE TABLE IF NOT EXISTS chat_attachments (
            id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
            message_id uuid NOT NULL REFERENCES chat_messages(id) ON DELETE CASCADE,
            file_name text NOT NULL,
            file_type text NOT NULL,
            file_size integer NOT NULL,
            storage_path text NOT NULL,
            created_at timestamp with time zone DEFAULT now()
          );

          ALTER TABLE chat_attachments ENABLE ROW LEVEL SECURITY;

          DROP POLICY IF EXISTS "Users can view attachments for their messages" ON chat_attachments;
          CREATE POLICY "Users can view attachments for their messages" ON chat_attachments
            FOR SELECT USING (
              EXISTS (
                SELECT 1 FROM chat_messages
                WHERE chat_messages.id = chat_attachments.message_id
                AND chat_messages.user_id = auth.uid()
              )
            );

          CREATE INDEX IF NOT EXISTS idx_chat_attachments_message_id ON chat_attachments(message_id);
        `);
        log('âœ… chat_attachments table created\n');
      } catch (err) {
        log('âŒ chat_attachments error: ' + err.message + '\n');
      }

      // Verify tables
      log('ðŸ“Š Verifying tables...\n');

      try {
        const { data: sessions, error: e1 } = await supabase.from('chat_sessions').select('*').limit(1);
        log(e1 ? 'âŒ chat_sessions: ' + e1.message : 'âœ… chat_sessions: exists');

        const { data: messages, error: e2 } = await supabase.from('chat_messages').select('*').limit(1);
        log(e2 ? 'âŒ chat_messages: ' + e2.message : 'âœ… chat_messages: exists');

        const { data: attachments, error: e3 } = await supabase.from('chat_attachments').select('*').limit(1);
        log(e3 ? 'âŒ chat_attachments: ' + e3.message : 'âœ… chat_attachments: exists');
      } catch (err) {
        log('âŒ Verification error: ' + err.message);
      }

      log('\nðŸŽ‰ Chat tables migration complete!');
    }

    applyMigrations().catch(err => {
      log('ðŸ’¥ Fatal error: ' + err.message);
    });
  </script>
</body>
</html>
